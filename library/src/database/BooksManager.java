package database;

import models.BookModel;
import models.BookType;

import java.io.*;
import java.util.*;
import java.util.stream.Collectors;

public class BooksManager extends BaseManager<BookModel> {

    private final static String BOOKS_FILE_PATH = "d:\\tmp\\new-books.txt";

    /**
     * keeps all books in library, key: bookId, value: BookBaseModel
     */
    private Map<Integer, BookModel> booksMap = new HashMap<>();

    /**
     * keeps all books in library
     * key: book title, value: List<BookModel>
     * Key if full bokk's title.
     */
    private final Map<String, List<BookModel>> fullTitleBooksMap = new HashMap<>();

    /**
     * keeps all books in library
     * key: book title generated by BookModel.getShortBookKey, value: List<BookModel>
     * In case of long book title, it could be simpler let user enter several first title words.
     * This map will keep all books redundant, but here key is taken from method getBookKey().
     * Such additional map should improve performance in large system.
     */
    private final Map<String, List<BookModel>> shortTitleBooksMap = new HashMap<>();

    /**
     * constructor
     * @param argsMap command-line arguments map, just in case any of managers will process its arguments
     * key: argument value, value: argument parameters after '=' character (can be empty)
     */
    protected BooksManager(Map<String, String> argsMap) {
        super(argsMap);
        initDB(BOOKS_FILE_PATH);
        initAutoCounter(booksMap.size());
    }

    /**
     * simply fetch book from map
     * @param bookId bookId
     * @return BookModel
     */
    protected synchronized BookModel getBook(int bookId) {
        return booksMap.get(bookId);
    }

    /**
     * adds book to specified cache map
     * @param bookKey book key
     * @param bookModel book model to store in cache
     * @param map cache to which book will be added
     */
    private void addToCache(String bookKey, BookModel bookModel, Map<String, List<BookModel>> map) {
        List<BookModel> books = map.get(bookKey);
        if (books == null) {
            books = new ArrayList<>();
        }
        books.add(bookModel);
        map.put(bookKey, books);
    }

    /**
     * 5. Should be possible to add new book to the library. ID should not be passed as argument. ID should be generated inside Library.
     * Adds book to database (now to internal caches)
     * @param bookType bookType defined in BookType
     * @param year book in which book was released
     * @param title title
     * @param authors list of authors
     * @return BookModel with automatically set book identifier
     */
    protected synchronized BookModel addBook(BookType bookType, int year, String title, List<String> authors) {
        BookModel bookModel = new BookModel(bookType, year, title, authors);
        bookModel.setId(getAndIncrement());
        booksMap.put(bookModel.getId(), bookModel);
        addToCache(title, bookModel, fullTitleBooksMap);
        addToCache(BookModel.getShortBookKey(bookModel), bookModel, shortTitleBooksMap);
        return bookModel;
    }

    /**
     * auxiliary method that removes book with specify title from internal caches
     * @param srcMap cache from which book will be removed
     * @param bookIdToRemove  book id to remove
     * @param title book's title (full or short version)
     */
    private void removeBookFromMap(Map<String, List<BookModel>> srcMap, final int bookIdToRemove, String title) {
        List<BookModel> list = srcMap.get(title);
        List<BookModel> filteredList = list.stream().filter(a -> a.getId() != bookIdToRemove).collect(Collectors.toList());
        srcMap.put(title, filteredList);
        if (filteredList.size() > 0) {
            srcMap.put(title, filteredList);
        } else {
            srcMap.remove(title);
        }
    }

    /**
     * 6. Should be possible to remove given book from the library (by ID) (such action should be possible only if the book with such ID exists and it is not currently lent).
     * method removes book from library if book exists and it is not currently lent
     * @param bookIdToRemove book id to remove
     * @return true if success false otherwise
     */
    public synchronized boolean removeBook(int bookIdToRemove) {
        BookModel bm = booksMap.get(bookIdToRemove);
        if (bm != null) {
            if (!bm.isBookLent()) {
                // remove book from all caches - atomic operation
                removeBookFromMap(shortTitleBooksMap, bookIdToRemove, BookModel.getShortBookKey(bm.getTitle()));
                removeBookFromMap(fullTitleBooksMap, bookIdToRemove, bm.getTitle());
                return booksMap.remove(bookIdToRemove) != null;
            }
        }
        return false;
    }

    /**
     * check if book is written by specific author
     * @param model BookModel
     * @param author author
     * @return true if found author, false otherwise
     */
    private boolean checkAuthor(BookModel model, String author) {
        return model.getAuthors().stream().filter(a -> a.equalsIgnoreCase(author)).findFirst().isPresent();
    }

    /**
     * finds book in cache for specific author
     * note: as we haven't specific cache for this operation, its execution in real environment can be longer
     * @param author author
     * @return list books by author
     */
    protected Optional<List<BookModel>> findBooksByAuthor(final String author) {
        if (author != null && author.trim().length()>0) {
            List<BookModel> list = booksMap.values().stream().filter(a -> checkAuthor(a, author)).collect(Collectors.toList());
            if (list.size()>0) {
                return Optional.of(list);
            }
        }
        return Optional.empty();
    }

    /**
     * finds book in cache released in specific year
     * note: as we haven't specific cache for this operation, its execution in real environment can be longer
     * @param year publication year
     * @return list books released in specific year
     */
    protected Optional<List<BookModel>> findBooksByYear(final int year) {
        if (year > 0) {
            List<BookModel> list = booksMap.values().stream().filter(a -> a.getYear() == year).collect(Collectors.toList());
            if (list.size()>0) {
                return Optional.of(list);
            }
        }
        return Optional.empty();
    }

    /**
     * finds books in cache with specific full title
     * @param title full book title
     * @return Optional<List<BookModel>>  list books with specific title
     */
    protected Optional<List<BookModel>> findBooksWithFullTittle(String title) {
        List<BookModel> list = fullTitleBooksMap.get(title);
        if (list != null) {
            return Optional.of(list);
        }
        return Optional.empty();
    }

    /**
     * finds books in cache with specific begin of title
     * @param titleShape title's beginning
     * @return Optional<List<BookModel>> list books with specific beginning of title
     */
    protected Optional<List<BookModel>> findBooksWithBeginOfBookTittle(String titleShape) {
        List<BookModel> books = shortTitleBooksMap.get(BookModel.getShortBookKey(titleShape));
        if (books != null && books.size() > 0) {
            List<BookModel> filteredBooks = books.stream().
                    filter(a -> a.getTitle().startsWith(titleShape)).
                    collect(Collectors.toList());
            if (filteredBooks.size() == 0) {
                filteredBooks = books.stream().
                        filter(a -> titleShape.startsWith(a.getTitle())).
                        collect(Collectors.toList());
            }
            return Optional.of(filteredBooks);
        }
        return Optional.empty();
    }

    /**
     * 7. Should allow to list all books in the library (distinctly).
     * Returned information should contain information how many is available or lent.
     * You can use simply System.out.println
     *
     * Method display information about books as described above
     */
    protected void presentBookStatus() {
        System.out.println();
        System.out.println("Books status report");
        System.out.println();
        int distinctBooks = 0;
        for(Map.Entry<String, List<BookModel>> entry : fullTitleBooksMap.entrySet()) {
            distinctBooks++;
            String title = entry.getKey();
            List<BookModel> booksList = entry.getValue();
            long lent = booksList.stream().filter(a -> a.isBookLent()).count();
            long numberOfBooks = booksList.size();
            long available = numberOfBooks - lent;
            System.out.println("book: " + distinctBooks + " title: " + title);
            System.out.println("               all: " + numberOfBooks + " lent: " + lent + " available: " + available);
        }
        System.out.println();
    }

    /**
     * 8. Should allow to search book by title, author, year (also other combinations like title AND author).
     *
     * Parameters can be specified or null or empty.
     * For specified parameters AND conditions will be used.
     *
     * First method try to find all books with specified title if it is given in parameters.
     * Next method will try to find books by authors (if author is specified).
     *      If title was specified, method will look only in results by title.
     *      If title was not specified, method will look in all library books  (in real env this can be time consuming process).
     * Next method will try to find books released in specified year (if parameter year>0)
     *      If there was realized previous search, this search will be in only in previous results.
     *      If there was not previous searching, this search will be in all books in library (in real env this can be time consuming process).
     *
     * @param fullTitle notification about kind of title; if true then it is full tittle, if false it is short form (beginning of the title)
     * @param title title if specified will be take to searching; if null or empty will be omitted in searching
     * @param author author if specified will be take to searching; if null or empty will be omitted in searching
     * @param year year if specified (value greater than 0) will be take to searching; if null or empty will be omitted in searching
     * @return list of books fulfill specified criteria
     */
    protected Optional<List<BookModel>> getBooks(boolean fullTitle, String title, String author, int year) {
        Optional<List<BookModel>> result = Optional.empty();

        boolean findTitle = title != null && title.trim().length()>0;
        boolean findAuthors = author != null && author.trim().length()>0;
        boolean findYear = year > 0;
        boolean firstSelect = true;

        if (findTitle) {
            firstSelect = false;
            result = filterByTitle(fullTitle, title);
        }

         if (findAuthors) {
            if (findTitle && result.isPresent()) {
                // continue search
                firstSelect = false;
                result = filterByAuthors(author, result);
            } else {
                // new search
                if (firstSelect) {
                    firstSelect = false;
                    result = filterByAuthorFirstTime(findBooksByAuthor(author));
                }
            }
        }

        if (findYear) {
            if ((findTitle || findAuthors) && result.isPresent()) {
                // continue search
                result = filterByYear(year, result);
            } else {
                if (firstSelect) {
                    // new search
                    result = filterByAuthorFirstTime(year);
                }
            }
        }

        return result;
    }

    private Optional<List<BookModel>> filterByYear(int year, Optional<List<BookModel>> result) {
        result = Optional.of(result.get().stream().filter(a -> a.getYear() == year).collect(Collectors.toList()));
        if (result.isPresent() && result.get().size()==0) {
            result = Optional.empty();
        }
        return result;
    }

    private Optional<List<BookModel>> filterByAuthorFirstTime(int year) {
        Optional<List<BookModel>> result;
        result = findBooksByYear(year);
        if (result.isPresent() && result.get().size()==0) {
            result = Optional.empty();
        }
        return result;
    }

    private Optional<List<BookModel>> filterByAuthorFirstTime(Optional<List<BookModel>> booksByAuthor) {
        Optional<List<BookModel>> result;
        result = booksByAuthor;
        if (result.isPresent() && result.get().size() == 0) {
            result = Optional.empty();
        }
        return result;
    }

    private Optional<List<BookModel>> filterByAuthors(String author, Optional<List<BookModel>> result) {
        result = Optional.of(result.get().stream().filter(a -> checkAuthor(a, author)).collect(Collectors.toList()));
        if (result.isPresent() && result.get().size()==0) {
            result = Optional.empty();
        }
        return result;
    }

    private Optional<List<BookModel>> filterByTitle(boolean fullTitle, String title) {
        Optional<List<BookModel>> result;
        result = fullTitle ? findBooksWithFullTittle(title) : findBooksWithBeginOfBookTittle(title);
        if (result.isPresent() && result.get().size()==0) {
            result = Optional.empty();
        }
        return result;
    }


    /*
     * auxiliary methods ###########################################################################
     */

    /**
     * auxiliary method for Library manager, displays detailed content of all books
     */
    protected void displayContent() {
        System.out.println();
        System.out.println("Number of books in library: " + booksMap.size());
        System.out.println();
        for (BookModel bm : booksMap.values()) {
            System.out.println(bm.toString());
        }
    }

    /**
     * auxiliary method for LentManager
     * @param bookIds list of book ids
     * @return short book description
     */
    protected String getBooksShortDescription(List<Integer> bookIds) {
        StringBuilder sb = new StringBuilder();
        for (Integer id : bookIds) {
            BookModel bm = booksMap.get(id);
            String stitle = bm.getShortBookTitle(40);
            sb.append(stitle).append(", ");
        }
        return sb.toString();
    }


    /*
    serialization related methods ################################################################
     */
    protected Map<Integer, BookModel> readContent() {
        return readContent(BOOKS_FILE_PATH);
    }

    @Override
    protected Map<Integer, BookModel> readContent(String file) {
        Map<Integer, BookModel> map = super.readContent(file);
        booksMap = map;
        return map;
    }

    protected void storeContent() {
        super.storeContent(booksMap, BOOKS_FILE_PATH);
    }


    /* NOT USED method - for future use or for remove ################################ */
    protected void storeContent(String file) {
        super.storeContent(booksMap, file);
    }

    protected synchronized BookModel removeBook(BookModel bookModel) {
        return booksMap.remove(bookModel.getId());
    }

    public synchronized Map<Integer, BookModel> getBooksMap() {
        return booksMap;
    }

    protected synchronized List<BookModel> getBook(String title) {
        return fullTitleBooksMap.get(title);
    }

    /*
    getters & setters ################################################################
     */

    @Override
    protected BookModel getBaseModel() {
        return new BookModel();
    }

    @Override
    protected void deserialize(BookModel model, ObjectInputStream inputStream) throws IOException, ClassNotFoundException {
        model.deserialize(inputStream);
    }

    @Override
    protected void serialize(BookModel baseModel, ObjectOutputStream outputStream) throws IOException {
        baseModel.serialize(outputStream);
    }

    @Override
    protected Integer getId(BookModel model) {
        return model.getId();
    }
}
